import { z } from "zod";
import { DbOperationArgs, MongoDBToolBase } from "../mongodbTool.js";
import { formatUntrustedData } from "../../tool.js";
import { checkIndexUsage } from "../../../helpers/indexCheck.js";
import { EJSON } from "bson";
export const AggregateArgs = {
    pipeline: z.array(z.object({}).passthrough()).describe("An array of aggregation stages to execute"),
};
export class AggregateTool extends MongoDBToolBase {
    constructor() {
        super(...arguments);
        this.name = "aggregate";
        this.description = "Run an aggregation against a MongoDB collection";
        this.argsShape = {
            ...DbOperationArgs,
            ...AggregateArgs,
        };
        this.operationType = "read";
    }
    async execute({ database, collection, pipeline, }) {
        const provider = await this.ensureConnected();
        // Check if aggregate operation uses an index if enabled
        if (this.config.indexCheck) {
            await checkIndexUsage(provider, database, collection, "aggregate", async () => {
                return provider
                    .aggregate(database, collection, pipeline, {}, { writeConcern: undefined })
                    .explain("queryPlanner");
            });
        }
        const documents = await provider.aggregate(database, collection, pipeline).toArray();
        return {
            content: formatUntrustedData(`The aggregation resulted in ${documents.length} documents.`, documents.length > 0 ? EJSON.stringify(documents) : undefined),
        };
    }
}
//# sourceMappingURL=aggregate.js.map