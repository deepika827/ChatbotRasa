"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamableHttpRunner = void 0;
const express_1 = __importDefault(require("express"));
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const base_js_1 = require("./base.js");
const logger_js_1 = require("../common/logger.js");
const crypto_1 = require("crypto");
const sessionStore_js_1 = require("../common/sessionStore.js");
const JSON_RPC_ERROR_CODE_PROCESSING_REQUEST_FAILED = -32000;
const JSON_RPC_ERROR_CODE_SESSION_ID_REQUIRED = -32001;
const JSON_RPC_ERROR_CODE_SESSION_ID_INVALID = -32002;
const JSON_RPC_ERROR_CODE_SESSION_NOT_FOUND = -32003;
const JSON_RPC_ERROR_CODE_INVALID_REQUEST = -32004;
class StreamableHttpRunner extends base_js_1.TransportRunnerBase {
    get serverAddress() {
        const result = this.httpServer?.address();
        if (typeof result === "string") {
            return result;
        }
        if (typeof result === "object" && result) {
            return `http://${result.address}:${result.port}`;
        }
        throw new Error("Server is not started yet");
    }
    constructor(userConfig, driverOptions, additionalLoggers = []) {
        super(userConfig, driverOptions, additionalLoggers);
    }
    async start() {
        const app = (0, express_1.default)();
        this.sessionStore = new sessionStore_js_1.SessionStore(this.userConfig.idleTimeoutMs, this.userConfig.notificationTimeoutMs, this.logger);
        app.enable("trust proxy"); // needed for reverse proxy support
        app.use(express_1.default.json());
        app.use((req, res, next) => {
            for (const [key, value] of Object.entries(this.userConfig.httpHeaders)) {
                const header = req.headers[key.toLowerCase()];
                if (!header || header !== value) {
                    res.status(403).send({ error: `Invalid value for header "${key}"` });
                    return;
                }
            }
            next();
        });
        const handleSessionRequest = async (req, res) => {
            const sessionId = req.headers["mcp-session-id"];
            if (!sessionId) {
                res.status(400).json({
                    jsonrpc: "2.0",
                    error: {
                        code: JSON_RPC_ERROR_CODE_SESSION_ID_REQUIRED,
                        message: `session id is required`,
                    },
                });
                return;
            }
            if (typeof sessionId !== "string") {
                res.status(400).json({
                    jsonrpc: "2.0",
                    error: {
                        code: JSON_RPC_ERROR_CODE_SESSION_ID_INVALID,
                        message: "session id is invalid",
                    },
                });
                return;
            }
            const transport = this.sessionStore.getSession(sessionId);
            if (!transport) {
                res.status(404).json({
                    jsonrpc: "2.0",
                    error: {
                        code: JSON_RPC_ERROR_CODE_SESSION_NOT_FOUND,
                        message: "session not found",
                    },
                });
                return;
            }
            await transport.handleRequest(req, res, req.body);
        };
        app.post("/mcp", this.withErrorHandling(async (req, res) => {
            const sessionId = req.headers["mcp-session-id"];
            if (sessionId) {
                await handleSessionRequest(req, res);
                return;
            }
            if (!(0, types_js_1.isInitializeRequest)(req.body)) {
                res.status(400).json({
                    jsonrpc: "2.0",
                    error: {
                        code: JSON_RPC_ERROR_CODE_INVALID_REQUEST,
                        message: `invalid request`,
                    },
                });
                return;
            }
            const server = this.setupServer();
            let keepAliveLoop;
            const transport = new streamableHttp_js_1.StreamableHTTPServerTransport({
                sessionIdGenerator: () => (0, crypto_1.randomUUID)().toString(),
                onsessioninitialized: (sessionId) => {
                    server.session.logger.setAttribute("sessionId", sessionId);
                    this.sessionStore.setSession(sessionId, transport, server.session.logger);
                    let failedPings = 0;
                    // eslint-disable-next-line @typescript-eslint/no-misused-promises
                    keepAliveLoop = setInterval(async () => {
                        try {
                            this.logger.debug({
                                id: logger_js_1.LogId.streamableHttpTransportKeepAlive,
                                context: "streamableHttpTransport",
                                message: "Sending ping",
                            });
                            await transport.send({
                                jsonrpc: "2.0",
                                method: "ping",
                            });
                            failedPings = 0;
                        }
                        catch (err) {
                            try {
                                failedPings++;
                                this.logger.warning({
                                    id: logger_js_1.LogId.streamableHttpTransportKeepAliveFailure,
                                    context: "streamableHttpTransport",
                                    message: `Error sending ping (attempt #${failedPings}): ${err instanceof Error ? err.message : String(err)}`,
                                });
                                if (failedPings > 3) {
                                    clearInterval(keepAliveLoop);
                                    await transport.close();
                                }
                            }
                            catch {
                                // Ignore the error of the transport close as there's nothing else
                                // we can do at this point.
                            }
                        }
                    }, 30000);
                },
                onsessionclosed: async (sessionId) => {
                    try {
                        await this.sessionStore.closeSession(sessionId, false);
                    }
                    catch (error) {
                        this.logger.error({
                            id: logger_js_1.LogId.streamableHttpTransportSessionCloseFailure,
                            context: "streamableHttpTransport",
                            message: `Error closing session: ${error instanceof Error ? error.message : String(error)}`,
                        });
                    }
                },
            });
            transport.onclose = () => {
                clearInterval(keepAliveLoop);
                server.close().catch((error) => {
                    this.logger.error({
                        id: logger_js_1.LogId.streamableHttpTransportCloseFailure,
                        context: "streamableHttpTransport",
                        message: `Error closing server: ${error instanceof Error ? error.message : String(error)}`,
                    });
                });
            };
            await server.connect(transport);
            await transport.handleRequest(req, res, req.body);
        }));
        app.get("/mcp", this.withErrorHandling(handleSessionRequest));
        app.delete("/mcp", this.withErrorHandling(handleSessionRequest));
        this.httpServer = await new Promise((resolve, reject) => {
            const result = app.listen(this.userConfig.httpPort, this.userConfig.httpHost, (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(result);
            });
        });
        this.logger.info({
            id: logger_js_1.LogId.streamableHttpTransportStarted,
            context: "streamableHttpTransport",
            message: `Server started on ${this.serverAddress}`,
            noRedaction: true,
        });
    }
    async closeTransport() {
        await Promise.all([
            this.sessionStore.closeAllSessions(),
            new Promise((resolve, reject) => {
                this.httpServer?.close((err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve();
                });
            }),
        ]);
    }
    withErrorHandling(fn) {
        return (req, res, next) => {
            fn(req, res, next).catch((error) => {
                this.logger.error({
                    id: logger_js_1.LogId.streamableHttpTransportRequestFailure,
                    context: "streamableHttpTransport",
                    message: `Error handling request: ${error instanceof Error ? error.message : String(error)}`,
                });
                res.status(400).json({
                    jsonrpc: "2.0",
                    error: {
                        code: JSON_RPC_ERROR_CODE_PROCESSING_REQUEST_FAILED,
                        message: `failed to handle request`,
                        data: error instanceof Error ? error.message : String(error),
                    },
                });
            });
        };
    }
}
exports.StreamableHttpRunner = StreamableHttpRunner;
//# sourceMappingURL=streamableHttp.js.map