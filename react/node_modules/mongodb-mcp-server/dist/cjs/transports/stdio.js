"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdioRunner = exports.EJsonReadBuffer = void 0;
exports.createStdioTransport = createStdioTransport;
const logger_js_1 = require("../common/logger.js");
const base_js_1 = require("./base.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const bson_1 = require("bson");
const stdio_js_1 = require("@modelcontextprotocol/sdk/server/stdio.js");
// This is almost a copy of ReadBuffer from @modelcontextprotocol/sdk
// but it uses EJSON.parse instead of JSON.parse to handle BSON types
class EJsonReadBuffer {
    append(chunk) {
        this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
    }
    readMessage() {
        if (!this._buffer) {
            return null;
        }
        const index = this._buffer.indexOf("\n");
        if (index === -1) {
            return null;
        }
        const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
        this._buffer = this._buffer.subarray(index + 1);
        // This is using EJSON.parse instead of JSON.parse to handle BSON types
        return types_js_1.JSONRPCMessageSchema.parse(bson_1.EJSON.parse(line));
    }
    clear() {
        this._buffer = undefined;
    }
}
exports.EJsonReadBuffer = EJsonReadBuffer;
// This is a hacky workaround for https://github.com/mongodb-js/mongodb-mcp-server/issues/211
// The underlying issue is that StdioServerTransport uses JSON.parse to deserialize
// messages, but that doesn't handle bson types, such as ObjectId when serialized as EJSON.
//
// This function creates a StdioServerTransport and replaces the internal readBuffer with EJsonReadBuffer
// that uses EJson.parse instead.
function createStdioTransport() {
    const server = new stdio_js_1.StdioServerTransport();
    server["_readBuffer"] = new EJsonReadBuffer();
    return server;
}
class StdioRunner extends base_js_1.TransportRunnerBase {
    constructor(userConfig, driverOptions, additionalLoggers = []) {
        super(userConfig, driverOptions, additionalLoggers);
    }
    async start() {
        try {
            this.server = this.setupServer();
            const transport = createStdioTransport();
            await this.server.connect(transport);
        }
        catch (error) {
            this.logger.emergency({
                id: logger_js_1.LogId.serverStartFailure,
                context: "server",
                message: `Fatal error running server: ${error}`,
            });
            process.exit(1);
        }
    }
    async closeTransport() {
        await this.server?.close();
    }
}
exports.StdioRunner = StdioRunner;
//# sourceMappingURL=stdio.js.map