"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExplainTool = void 0;
const mongodbTool_js_1 = require("../mongodbTool.js");
const tool_js_1 = require("../../tool.js");
const zod_1 = require("zod");
const mongodb_1 = require("mongodb");
const aggregate_js_1 = require("../read/aggregate.js");
const find_js_1 = require("../read/find.js");
const count_js_1 = require("../read/count.js");
class ExplainTool extends mongodbTool_js_1.MongoDBToolBase {
    constructor() {
        super(...arguments);
        this.name = "explain";
        this.description = "Returns statistics describing the execution of the winning plan chosen by the query optimizer for the evaluated method";
        this.argsShape = {
            ...mongodbTool_js_1.DbOperationArgs,
            method: zod_1.z
                .array(zod_1.z.discriminatedUnion("name", [
                zod_1.z.object({
                    name: zod_1.z.literal("aggregate"),
                    arguments: zod_1.z.object(aggregate_js_1.AggregateArgs),
                }),
                zod_1.z.object({
                    name: zod_1.z.literal("find"),
                    arguments: zod_1.z.object(find_js_1.FindArgs),
                }),
                zod_1.z.object({
                    name: zod_1.z.literal("count"),
                    arguments: zod_1.z.object(count_js_1.CountArgs),
                }),
            ]))
                .describe("The method and its arguments to run"),
        };
        this.operationType = "metadata";
    }
    async execute({ database, collection, method: methods, }) {
        const provider = await this.ensureConnected();
        const method = methods[0];
        if (!method) {
            throw new Error("No method provided. Expected one of the following: `aggregate`, `find`, or `count`");
        }
        let result;
        switch (method.name) {
            case "aggregate": {
                const { pipeline } = method.arguments;
                result = await provider
                    .aggregate(database, collection, pipeline, {}, {
                    writeConcern: undefined,
                })
                    .explain(ExplainTool.defaultVerbosity);
                break;
            }
            case "find": {
                const { filter, ...rest } = method.arguments;
                result = await provider
                    .find(database, collection, filter, { ...rest })
                    .explain(ExplainTool.defaultVerbosity);
                break;
            }
            case "count": {
                const { query } = method.arguments;
                result = await provider.runCommandWithCheck(database, {
                    explain: {
                        count: collection,
                        query,
                    },
                    verbosity: ExplainTool.defaultVerbosity,
                });
                break;
            }
        }
        return {
            content: (0, tool_js_1.formatUntrustedData)(`Here is some information about the winning plan chosen by the query optimizer for running the given \`${method.name}\` operation in "${database}.${collection}". This information can be used to understand how the query was executed and to optimize the query performance.`, JSON.stringify(result)),
        };
    }
}
exports.ExplainTool = ExplainTool;
ExplainTool.defaultVerbosity = mongodb_1.ExplainVerbosity.queryPlanner;
//# sourceMappingURL=explain.js.map