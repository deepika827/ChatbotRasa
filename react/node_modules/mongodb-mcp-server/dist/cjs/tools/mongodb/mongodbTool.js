"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDBToolBase = exports.DbOperationArgs = void 0;
const zod_1 = require("zod");
const tool_js_1 = require("../tool.js");
const errors_js_1 = require("../../common/errors.js");
const logger_js_1 = require("../../common/logger.js");
exports.DbOperationArgs = {
    database: zod_1.z.string().describe("Database name"),
    collection: zod_1.z.string().describe("Collection name"),
};
class MongoDBToolBase extends tool_js_1.ToolBase {
    constructor() {
        super(...arguments);
        this.category = "mongodb";
    }
    async ensureConnected() {
        if (!this.session.isConnectedToMongoDB) {
            if (this.session.connectedAtlasCluster) {
                throw new errors_js_1.MongoDBError(errors_js_1.ErrorCodes.NotConnectedToMongoDB, `Attempting to connect to Atlas cluster "${this.session.connectedAtlasCluster.clusterName}", try again in a few seconds.`);
            }
            if (this.config.connectionString) {
                try {
                    await this.connectToMongoDB(this.config.connectionString);
                }
                catch (error) {
                    this.session.logger.error({
                        id: logger_js_1.LogId.mongodbConnectFailure,
                        context: "mongodbTool",
                        message: `Failed to connect to MongoDB instance using the connection string from the config: ${error}`,
                    });
                    throw new errors_js_1.MongoDBError(errors_js_1.ErrorCodes.MisconfiguredConnectionString, "Not connected to MongoDB.");
                }
            }
        }
        if (!this.session.isConnectedToMongoDB) {
            throw new errors_js_1.MongoDBError(errors_js_1.ErrorCodes.NotConnectedToMongoDB, "Not connected to MongoDB");
        }
        return this.session.serviceProvider;
    }
    register(server) {
        this.server = server;
        return super.register(server);
    }
    handleError(error, args) {
        if (error instanceof errors_js_1.MongoDBError) {
            const connectTools = this.server?.tools
                .filter((t) => t.operationType === "connect")
                .sort((a, b) => a.category.localeCompare(b.category)); // Sort Altas tools before MongoDB tools
            // Find the first Atlas connect tool if available and suggest to the LLM to use it.
            // Note: if we ever have multiple Atlas connect tools, we may want to refine this logic to select the most appropriate one.
            const atlasConnectTool = connectTools?.find((t) => t.category === "atlas");
            const llmConnectHint = atlasConnectTool
                ? `Note to LLM: prefer using the "${atlasConnectTool.name}" tool to connect to an Atlas cluster over using a connection string. Make sure to ask the user to specify a cluster name they want to connect to or ask them if they want to use the "list-clusters" tool to list all their clusters. Do not invent cluster names or connection strings unless the user has explicitly specified them. If they've previously connected to MongoDB using MCP, you can ask them if they want to reconnect using the same cluster/connection.`
                : "Note to LLM: do not invent connection strings and explicitly ask the user to provide one. If they have previously connected to MongoDB using MCP, you can ask them if they want to reconnect using the same connection string.";
            const connectToolsNames = connectTools?.map((t) => `"${t.name}"`).join(", ");
            const connectionStatus = this.session.connectionManager.currentConnectionState;
            const additionalPromptForConnectivity = [];
            if (connectionStatus.tag === "connecting" && connectionStatus.oidcConnectionType) {
                additionalPromptForConnectivity.push({
                    type: "text",
                    text: `The user needs to finish their OIDC connection by opening '${connectionStatus.oidcLoginUrl}' in the browser and use the following user code: '${connectionStatus.oidcUserCode}'`,
                });
            }
            else {
                additionalPromptForConnectivity.push({
                    type: "text",
                    text: connectToolsNames
                        ? `Please use one of the following tools: ${connectToolsNames} to connect to a MongoDB instance or update the MCP server configuration to include a connection string. ${llmConnectHint}`
                        : "There are no tools available to connect. Please update the configuration to include a connection string and restart the server.",
                });
            }
            switch (error.code) {
                case errors_js_1.ErrorCodes.NotConnectedToMongoDB:
                    return {
                        content: [
                            {
                                type: "text",
                                text: "You need to connect to a MongoDB instance before you can access its data.",
                            },
                            ...additionalPromptForConnectivity,
                        ],
                        isError: true,
                    };
                case errors_js_1.ErrorCodes.MisconfiguredConnectionString:
                    return {
                        content: [
                            {
                                type: "text",
                                text: "The configured connection string is not valid. Please check the connection string and confirm it points to a valid MongoDB instance.",
                            },
                            {
                                type: "text",
                                text: connectTools
                                    ? `Alternatively, you can use one of the following tools: ${connectToolsNames} to connect to a MongoDB instance. ${llmConnectHint}`
                                    : "Please update the configuration to use a valid connection string and restart the server.",
                            },
                        ],
                        isError: true,
                    };
                case errors_js_1.ErrorCodes.ForbiddenCollscan:
                    return {
                        content: [
                            {
                                type: "text",
                                text: error.message,
                            },
                        ],
                        isError: true,
                    };
            }
        }
        return super.handleError(error, args);
    }
    connectToMongoDB(connectionString) {
        return this.session.connectToMongoDB({ connectionString });
    }
    resolveTelemetryMetadata(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    args) {
        const metadata = {};
        // Add projectId to the metadata if running a MongoDB operation to an Atlas cluster
        if (this.session.connectedAtlasCluster?.projectId) {
            metadata.projectId = this.session.connectedAtlasCluster.projectId;
        }
        return metadata;
    }
}
exports.MongoDBToolBase = MongoDBToolBase;
//# sourceMappingURL=mongodbTool.js.map