"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectTool = void 0;
const zod_1 = require("zod");
const mongodbTool_js_1 = require("../mongodbTool.js");
const assert_1 = __importDefault(require("assert"));
const disconnectedSchema = zod_1.z
    .object({
    connectionString: zod_1.z.string().describe("MongoDB connection string (in the mongodb:// or mongodb+srv:// format)"),
})
    .describe("Options for connecting to MongoDB.");
const connectedSchema = zod_1.z
    .object({
    connectionString: zod_1.z
        .string()
        .optional()
        .describe("MongoDB connection string to switch to (in the mongodb:// or mongodb+srv:// format)"),
})
    .describe("Options for switching the current MongoDB connection. If a connection string is not provided, the connection string from the config will be used.");
const connectedName = "switch-connection";
const disconnectedName = "connect";
const connectedDescription = "Switch to a different MongoDB connection. If the user has configured a connection string or has previously called the connect tool, a connection is already established and there's no need to call this tool unless the user has explicitly requested to switch to a new instance.";
const disconnectedDescription = "Connect to a MongoDB instance";
class ConnectTool extends mongodbTool_js_1.MongoDBToolBase {
    constructor(session, config, telemetry) {
        super(session, config, telemetry);
        this.name = disconnectedName;
        this.description = disconnectedDescription;
        // Here the default is empty just to trigger registration, but we're going to override it with the correct
        // schema in the register method.
        this.argsShape = {
            connectionString: zod_1.z.string().optional(),
        };
        this.operationType = "connect";
        session.on("connect", () => {
            this.updateMetadata();
        });
        session.on("disconnect", () => {
            this.updateMetadata();
        });
    }
    async execute({ connectionString }) {
        switch (this.name) {
            case disconnectedName:
                (0, assert_1.default)(connectionString, "Connection string is required");
                break;
            case connectedName:
                connectionString ?? (connectionString = this.config.connectionString);
                (0, assert_1.default)(connectionString, "Cannot switch to a new connection because no connection string was provided and no default connection string is configured.");
                break;
        }
        await this.connectToMongoDB(connectionString);
        this.updateMetadata();
        return {
            content: [{ type: "text", text: "Successfully connected to MongoDB." }],
        };
    }
    register(server) {
        if (super.register(server)) {
            this.updateMetadata();
            return true;
        }
        return false;
    }
    updateMetadata() {
        if (this.session.isConnectedToMongoDB) {
            this.update?.({
                name: connectedName,
                description: connectedDescription,
                inputSchema: connectedSchema,
            });
        }
        else {
            this.update?.({
                name: disconnectedName,
                description: disconnectedDescription,
                inputSchema: disconnectedSchema,
            });
        }
    }
}
exports.ConnectTool = ConnectTool;
//# sourceMappingURL=connect.js.map