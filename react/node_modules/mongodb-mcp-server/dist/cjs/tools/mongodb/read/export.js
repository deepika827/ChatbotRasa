"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportTool = void 0;
const zod_1 = __importDefault(require("zod"));
const bson_1 = require("bson");
const mongodbTool_js_1 = require("../mongodbTool.js");
const find_js_1 = require("./find.js");
const exportsManager_js_1 = require("../../../common/exportsManager.js");
const aggregate_js_1 = require("./aggregate.js");
class ExportTool extends mongodbTool_js_1.MongoDBToolBase {
    constructor() {
        super(...arguments);
        this.name = "export";
        this.description = "Export a query or aggregation results in the specified EJSON format.";
        this.argsShape = {
            ...mongodbTool_js_1.DbOperationArgs,
            exportTitle: zod_1.default.string().describe("A short description to uniquely identify the export."),
            exportTarget: zod_1.default
                .array(zod_1.default.discriminatedUnion("name", [
                zod_1.default.object({
                    name: zod_1.default
                        .literal("find")
                        .describe("The literal name 'find' to represent a find cursor as target."),
                    arguments: zod_1.default
                        .object({
                        ...find_js_1.FindArgs,
                        limit: find_js_1.FindArgs.limit.removeDefault(),
                    })
                        .describe("The arguments for 'find' operation."),
                }),
                zod_1.default.object({
                    name: zod_1.default
                        .literal("aggregate")
                        .describe("The literal name 'aggregate' to represent an aggregation cursor as target."),
                    arguments: zod_1.default.object(aggregate_js_1.AggregateArgs).describe("The arguments for 'aggregate' operation."),
                }),
            ]))
                .describe("The export target along with its arguments."),
            jsonExportFormat: exportsManager_js_1.jsonExportFormat
                .default("relaxed")
                .describe([
                "The format to be used when exporting collection data as EJSON with default being relaxed.",
                "relaxed: A string format that emphasizes readability and interoperability at the expense of type preservation. That is, conversion from relaxed format to BSON can lose type information.",
                "canonical: A string format that emphasizes type preservation at the expense of readability and interoperability. That is, conversion from canonical to BSON will generally preserve type information except in certain specific cases.",
            ].join("\n")),
        };
        this.operationType = "read";
    }
    async execute({ database, collection, jsonExportFormat, exportTitle, exportTarget: target, }) {
        const provider = await this.ensureConnected();
        const exportTarget = target[0];
        if (!exportTarget) {
            throw new Error("Export target not provided. Expected one of the following: `aggregate`, `find`");
        }
        let cursor;
        if (exportTarget.name === "find") {
            const { filter, projection, sort, limit } = exportTarget.arguments;
            cursor = provider.find(database, collection, filter ?? {}, {
                projection,
                sort,
                limit,
                promoteValues: false,
                bsonRegExp: true,
            });
        }
        else {
            const { pipeline } = exportTarget.arguments;
            cursor = provider.aggregate(database, collection, pipeline, {
                promoteValues: false,
                bsonRegExp: true,
                allowDiskUse: true,
            });
        }
        const exportName = `${database}.${collection}.${new bson_1.ObjectId().toString()}.json`;
        const { exportURI, exportPath } = await this.session.exportsManager.createJSONExport({
            input: cursor,
            exportName,
            exportTitle: exportTitle ||
                `Export for namespace ${database}.${collection} requested on ${new Date().toLocaleString()}`,
            jsonExportFormat,
        });
        const toolCallContent = [
            // Not all the clients as of this commit understands how to
            // parse a resource_link so we provide a text result for them to
            // understand what to do with the result.
            {
                type: "text",
                text: `Data for namespace ${database}.${collection} is being exported and will be made available under resource URI - "${exportURI}".`,
            },
            {
                type: "resource_link",
                name: exportName,
                uri: exportURI,
                description: "Resource URI for fetching exported data once it is ready.",
                mimeType: "application/json",
            },
        ];
        // This special case is to make it easier to work with exported data for
        // clients that still cannot reference resources (Cursor).
        // More information here: https://jira.mongodb.org/browse/MCP-104
        if (this.isServerRunningLocally()) {
            toolCallContent.push({
                type: "text",
                text: `Optionally, when the export is finished, the exported data can also be accessed under path - "${exportPath}"`,
            });
        }
        return {
            content: toolCallContent,
        };
    }
    isServerRunningLocally() {
        return this.config.transport === "stdio" || ["127.0.0.1", "localhost"].includes(this.config.httpHost);
    }
}
exports.ExportTool = ExportTool;
//# sourceMappingURL=export.js.map