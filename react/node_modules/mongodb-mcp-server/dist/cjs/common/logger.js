"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NullLogger = exports.CompositeLogger = exports.McpLogger = exports.DiskLogger = exports.ConsoleLogger = exports.LoggerBase = exports.LogId = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const mongodb_log_writer_1 = require("mongodb-log-writer");
const mongodb_redact_1 = __importDefault(require("mongodb-redact"));
const events_1 = require("events");
exports.LogId = {
    serverStartFailure: (0, mongodb_log_writer_1.mongoLogId)(1000001),
    serverInitialized: (0, mongodb_log_writer_1.mongoLogId)(1000002),
    serverCloseRequested: (0, mongodb_log_writer_1.mongoLogId)(1000003),
    serverClosed: (0, mongodb_log_writer_1.mongoLogId)(1000004),
    serverCloseFailure: (0, mongodb_log_writer_1.mongoLogId)(1000005),
    serverDuplicateLoggers: (0, mongodb_log_writer_1.mongoLogId)(1000006),
    serverMcpClientSet: (0, mongodb_log_writer_1.mongoLogId)(1000007),
    atlasCheckCredentials: (0, mongodb_log_writer_1.mongoLogId)(1001001),
    atlasDeleteDatabaseUserFailure: (0, mongodb_log_writer_1.mongoLogId)(1001002),
    atlasConnectFailure: (0, mongodb_log_writer_1.mongoLogId)(1001003),
    atlasInspectFailure: (0, mongodb_log_writer_1.mongoLogId)(1001004),
    atlasConnectAttempt: (0, mongodb_log_writer_1.mongoLogId)(1001005),
    atlasConnectSucceeded: (0, mongodb_log_writer_1.mongoLogId)(1001006),
    atlasApiRevokeFailure: (0, mongodb_log_writer_1.mongoLogId)(1001007),
    atlasIpAccessListAdded: (0, mongodb_log_writer_1.mongoLogId)(1001008),
    atlasIpAccessListAddFailure: (0, mongodb_log_writer_1.mongoLogId)(1001009),
    telemetryDisabled: (0, mongodb_log_writer_1.mongoLogId)(1002001),
    telemetryEmitFailure: (0, mongodb_log_writer_1.mongoLogId)(1002002),
    telemetryEmitStart: (0, mongodb_log_writer_1.mongoLogId)(1002003),
    telemetryEmitSuccess: (0, mongodb_log_writer_1.mongoLogId)(1002004),
    telemetryMetadataError: (0, mongodb_log_writer_1.mongoLogId)(1002005),
    deviceIdResolutionError: (0, mongodb_log_writer_1.mongoLogId)(1002006),
    deviceIdTimeout: (0, mongodb_log_writer_1.mongoLogId)(1002007),
    toolExecute: (0, mongodb_log_writer_1.mongoLogId)(1003001),
    toolExecuteFailure: (0, mongodb_log_writer_1.mongoLogId)(1003002),
    toolDisabled: (0, mongodb_log_writer_1.mongoLogId)(1003003),
    mongodbConnectFailure: (0, mongodb_log_writer_1.mongoLogId)(1004001),
    mongodbDisconnectFailure: (0, mongodb_log_writer_1.mongoLogId)(1004002),
    toolUpdateFailure: (0, mongodb_log_writer_1.mongoLogId)(1005001),
    resourceUpdateFailure: (0, mongodb_log_writer_1.mongoLogId)(1005002),
    streamableHttpTransportStarted: (0, mongodb_log_writer_1.mongoLogId)(1006001),
    streamableHttpTransportSessionCloseFailure: (0, mongodb_log_writer_1.mongoLogId)(1006002),
    streamableHttpTransportSessionCloseNotification: (0, mongodb_log_writer_1.mongoLogId)(1006003),
    streamableHttpTransportSessionCloseNotificationFailure: (0, mongodb_log_writer_1.mongoLogId)(1006004),
    streamableHttpTransportRequestFailure: (0, mongodb_log_writer_1.mongoLogId)(1006005),
    streamableHttpTransportCloseFailure: (0, mongodb_log_writer_1.mongoLogId)(1006006),
    streamableHttpTransportKeepAliveFailure: (0, mongodb_log_writer_1.mongoLogId)(1006007),
    streamableHttpTransportKeepAlive: (0, mongodb_log_writer_1.mongoLogId)(1006008),
    exportCleanupError: (0, mongodb_log_writer_1.mongoLogId)(1007001),
    exportCreationError: (0, mongodb_log_writer_1.mongoLogId)(1007002),
    exportCreationCleanupError: (0, mongodb_log_writer_1.mongoLogId)(1007003),
    exportReadError: (0, mongodb_log_writer_1.mongoLogId)(1007004),
    exportCloseError: (0, mongodb_log_writer_1.mongoLogId)(1007005),
    exportedDataListError: (0, mongodb_log_writer_1.mongoLogId)(1007006),
    exportedDataAutoCompleteError: (0, mongodb_log_writer_1.mongoLogId)(1007007),
    exportLockError: (0, mongodb_log_writer_1.mongoLogId)(1007008),
    oidcFlow: (0, mongodb_log_writer_1.mongoLogId)(1008001),
};
class LoggerBase extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.defaultUnredactedLogger = "mcp";
    }
    log(level, payload) {
        // If no explicit value is supplied for unredacted loggers, default to "mcp"
        const noRedaction = payload.noRedaction !== undefined ? payload.noRedaction : this.defaultUnredactedLogger;
        this.logCore(level, {
            ...payload,
            message: this.redactIfNecessary(payload.message, noRedaction),
        });
    }
    redactIfNecessary(message, noRedaction) {
        if (typeof noRedaction === "boolean" && noRedaction) {
            // If the consumer has supplied noRedaction: true, we don't redact the log message
            // regardless of the logger type
            return message;
        }
        if (typeof noRedaction === "string" && noRedaction === this.type) {
            // If the consumer has supplied noRedaction: logger-type, we skip redacting if
            // our logger type is the same as what the consumer requested
            return message;
        }
        if (typeof noRedaction === "object" &&
            Array.isArray(noRedaction) &&
            this.type &&
            noRedaction.indexOf(this.type) !== -1) {
            // If the consumer has supplied noRedaction: array, we skip redacting if our logger
            // type is included in that array
            return message;
        }
        return (0, mongodb_redact_1.default)(message);
    }
    info(payload) {
        this.log("info", payload);
    }
    error(payload) {
        this.log("error", payload);
    }
    debug(payload) {
        this.log("debug", payload);
    }
    notice(payload) {
        this.log("notice", payload);
    }
    warning(payload) {
        this.log("warning", payload);
    }
    critical(payload) {
        this.log("critical", payload);
    }
    alert(payload) {
        this.log("alert", payload);
    }
    emergency(payload) {
        this.log("emergency", payload);
    }
    mapToMongoDBLogLevel(level) {
        switch (level) {
            case "info":
                return "info";
            case "warning":
                return "warn";
            case "error":
                return "error";
            case "notice":
            case "debug":
                return "debug";
            case "critical":
            case "alert":
            case "emergency":
                return "fatal";
            default:
                return "info";
        }
    }
}
exports.LoggerBase = LoggerBase;
class ConsoleLogger extends LoggerBase {
    constructor() {
        super(...arguments);
        this.type = "console";
    }
    logCore(level, payload) {
        const { id, context, message } = payload;
        console.error(`[${level.toUpperCase()}] ${id.__value} - ${context}: ${message} (${process.pid}${this.serializeAttributes(payload.attributes)})`);
    }
    serializeAttributes(attributes) {
        if (!attributes || Object.keys(attributes).length === 0) {
            return "";
        }
        return `, ${Object.entries(attributes)
            .map(([key, value]) => `${key}=${value}`)
            .join(", ")}`;
    }
}
exports.ConsoleLogger = ConsoleLogger;
class DiskLogger extends LoggerBase {
    constructor(logPath, onError) {
        super();
        this.bufferedMessages = [];
        this.type = "disk";
        void this.initialize(logPath, onError);
    }
    async initialize(logPath, onError) {
        try {
            await promises_1.default.mkdir(logPath, { recursive: true });
            const manager = new mongodb_log_writer_1.MongoLogManager({
                directory: logPath,
                retentionDays: 30,
                onwarn: console.warn,
                onerror: console.error,
                gzip: false,
                retentionGB: 1,
            });
            await manager.cleanupOldLogFiles();
            this.logWriter = await manager.createLogWriter();
            for (const message of this.bufferedMessages) {
                this.logCore(message.level, message.payload);
            }
            this.bufferedMessages = [];
            this.emit("initialized");
        }
        catch (error) {
            onError(error);
        }
    }
    logCore(level, payload) {
        if (!this.logWriter) {
            // If the log writer is not initialized, buffer the message
            this.bufferedMessages.push({ level, payload });
            return;
        }
        const { id, context, message } = payload;
        const mongoDBLevel = this.mapToMongoDBLogLevel(level);
        this.logWriter[mongoDBLevel]("MONGODB-MCP", id, context, message, payload.attributes);
    }
}
exports.DiskLogger = DiskLogger;
class McpLogger extends LoggerBase {
    constructor(server) {
        super();
        this.server = server;
        this.type = "mcp";
    }
    logCore(level, payload) {
        // Only log if the server is connected
        if (!this.server.mcpServer.isConnected()) {
            return;
        }
        const minimumLevel = McpLogger.LOG_LEVELS.indexOf(this.server.mcpLogLevel);
        const currentLevel = McpLogger.LOG_LEVELS.indexOf(level);
        if (minimumLevel > currentLevel) {
            // Don't log if the requested level is lower than the minimum level
            return;
        }
        void this.server.mcpServer.server.sendLoggingMessage({
            level,
            data: `[${payload.context}]: ${payload.message}`,
        });
    }
}
exports.McpLogger = McpLogger;
McpLogger.LOG_LEVELS = [
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency",
];
class CompositeLogger extends LoggerBase {
    constructor(...loggers) {
        super();
        this.loggers = [];
        this.attributes = {};
        this.loggers = loggers;
    }
    addLogger(logger) {
        this.loggers.push(logger);
    }
    log(level, payload) {
        // Override the public method to avoid the base logger redacting the message payload
        for (const logger of this.loggers) {
            const attributes = Object.keys(this.attributes).length > 0 || payload.attributes
                ? { ...this.attributes, ...payload.attributes }
                : undefined;
            logger.log(level, { ...payload, attributes });
        }
    }
    logCore() {
        throw new Error("logCore should never be invoked on CompositeLogger");
    }
    setAttribute(key, value) {
        this.attributes[key] = value;
    }
}
exports.CompositeLogger = CompositeLogger;
class NullLogger extends LoggerBase {
    logCore() {
        // No-op logger, does not log anything
    }
}
exports.NullLogger = NullLogger;
//# sourceMappingURL=logger.js.map