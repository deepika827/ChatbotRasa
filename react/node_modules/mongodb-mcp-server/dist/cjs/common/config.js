"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.driverOptions = exports.defaultDriverOptions = exports.config = exports.defaultUserConfig = void 0;
exports.setupUserConfig = setupUserConfig;
exports.setupDriverConfig = setupDriverConfig;
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const yargs_parser_1 = __importDefault(require("yargs-parser"));
const arg_parser_1 = require("@mongosh/arg-parser");
// From: https://github.com/mongodb-js/mongosh/blob/main/packages/cli-repl/src/arg-parser.ts
const OPTIONS = {
    string: [
        "apiBaseUrl",
        "apiClientId",
        "apiClientSecret",
        "connectionString",
        "httpHost",
        "httpPort",
        "idleTimeoutMs",
        "logPath",
        "notificationTimeoutMs",
        "telemetry",
        "transport",
        "apiVersion",
        "authenticationDatabase",
        "authenticationMechanism",
        "browser",
        "db",
        "gssapiHostName",
        "gssapiServiceName",
        "host",
        "oidcFlows",
        "oidcRedirectUri",
        "password",
        "port",
        "sslCAFile",
        "sslCRLFile",
        "sslCertificateSelector",
        "sslDisabledProtocols",
        "sslPEMKeyFile",
        "sslPEMKeyPassword",
        "sspiHostnameCanonicalization",
        "sspiRealmOverride",
        "tlsCAFile",
        "tlsCRLFile",
        "tlsCertificateKeyFile",
        "tlsCertificateKeyFilePassword",
        "tlsCertificateSelector",
        "tlsDisabledProtocols",
        "username",
    ],
    boolean: [
        "apiDeprecationErrors",
        "apiStrict",
        "help",
        "indexCheck",
        "ipv6",
        "nodb",
        "oidcIdTokenAsAccessToken",
        "oidcNoNonce",
        "oidcTrustedEndpoint",
        "readOnly",
        "retryWrites",
        "ssl",
        "sslAllowInvalidCertificates",
        "sslAllowInvalidHostnames",
        "sslFIPSMode",
        "tls",
        "tlsAllowInvalidCertificates",
        "tlsAllowInvalidHostnames",
        "tlsFIPSMode",
        "version",
    ],
    array: ["disabledTools", "loggers"],
    alias: {
        h: "help",
        p: "password",
        u: "username",
        "build-info": "buildInfo",
        browser: "browser",
        oidcDumpTokens: "oidcDumpTokens",
        oidcRedirectUrl: "oidcRedirectUri",
        oidcIDTokenAsAccessToken: "oidcIdTokenAsAccessToken",
    },
    configuration: {
        "camel-case-expansion": false,
        "unknown-options-as-args": true,
        "parse-positional-numbers": false,
        "parse-numbers": false,
        "greedy-arrays": true,
        "short-option-groups": false,
    },
};
function isConnectionSpecifier(arg) {
    return (arg !== undefined &&
        (arg.startsWith("mongodb://") ||
            arg.startsWith("mongodb+srv://") ||
            !(arg.endsWith(".js") || arg.endsWith(".mongodb"))));
}
exports.defaultUserConfig = {
    apiBaseUrl: "https://cloud.mongodb.com/",
    logPath: getLogPath(),
    exportsPath: getExportsPath(),
    exportTimeoutMs: 300000, // 5 minutes
    exportCleanupIntervalMs: 120000, // 2 minutes
    disabledTools: [],
    telemetry: "enabled",
    readOnly: false,
    indexCheck: false,
    transport: "stdio",
    httpPort: 3000,
    httpHost: "127.0.0.1",
    loggers: ["disk", "mcp"],
    idleTimeoutMs: 600000, // 10 minutes
    notificationTimeoutMs: 540000, // 9 minutes
    httpHeaders: {},
};
exports.config = setupUserConfig({
    defaults: exports.defaultUserConfig,
    cli: process.argv,
    env: process.env,
});
function getLocalDataPath() {
    return process.platform === "win32"
        ? path_1.default.join(process.env.LOCALAPPDATA || process.env.APPDATA || os_1.default.homedir(), "mongodb")
        : path_1.default.join(os_1.default.homedir(), ".mongodb");
}
exports.defaultDriverOptions = {
    readConcern: {
        level: "local",
    },
    readPreference: "secondaryPreferred",
    writeConcern: {
        w: "majority",
    },
    timeoutMS: 30000,
    proxy: { useEnvironmentVariableProxies: true },
    applyProxyToOIDC: true,
};
exports.driverOptions = setupDriverConfig({
    config: exports.config,
    defaults: exports.defaultDriverOptions,
});
function getLogPath() {
    const logPath = path_1.default.join(getLocalDataPath(), "mongodb-mcp", ".app-logs");
    return logPath;
}
function getExportsPath() {
    return path_1.default.join(getLocalDataPath(), "mongodb-mcp", "exports");
}
// Gets the config supplied by the user as environment variables. The variable names
// are prefixed with `MDB_MCP_` and the keys match the UserConfig keys, but are converted
// to SNAKE_UPPER_CASE.
function parseEnvConfig(env) {
    function setValue(obj, path, value) {
        const currentField = path.shift();
        if (!currentField) {
            return;
        }
        if (path.length === 0) {
            const numberValue = Number(value);
            if (!isNaN(numberValue)) {
                obj[currentField] = numberValue;
                return;
            }
            const booleanValue = value.toLocaleLowerCase();
            if (booleanValue === "true" || booleanValue === "false") {
                obj[currentField] = booleanValue === "true";
                return;
            }
            // Try to parse an array of values
            if (value.indexOf(",") !== -1) {
                obj[currentField] = value.split(",").map((v) => v.trim());
                return;
            }
            obj[currentField] = value;
            return;
        }
        if (!obj[currentField]) {
            obj[currentField] = {};
        }
        setValue(obj[currentField], path, value);
    }
    const result = {};
    const mcpVariables = Object.entries(env).filter(([key, value]) => value !== undefined && key.startsWith("MDB_MCP_"));
    for (const [key, value] of mcpVariables) {
        const fieldPath = key
            .replace("MDB_MCP_", "")
            .split(".")
            .map((part) => SNAKE_CASE_toCamelCase(part));
        setValue(result, fieldPath, value);
    }
    return result;
}
function SNAKE_CASE_toCamelCase(str) {
    return str.toLowerCase().replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace("_", ""));
}
// Right now we have arguments that are not compatible with the format used in mongosh.
// An example is using --connectionString and positional arguments.
// We will consolidate them in a way where the mongosh format takes precedence.
// We will warn users that previous configuration is deprecated in favour of
// whatever is in mongosh.
function parseCliConfig(args) {
    const programArgs = args.slice(2);
    const parsed = (0, yargs_parser_1.default)(programArgs, OPTIONS);
    const positionalArguments = parsed._ ?? [];
    // if we have a positional argument that matches a connection string
    // store it as the connection specifier and remove it from the argument
    // list, so it doesn't get misunderstood by the mongosh args-parser
    if (!parsed.nodb && isConnectionSpecifier(positionalArguments[0])) {
        parsed.connectionSpecifier = positionalArguments.shift();
    }
    delete parsed._;
    return parsed;
}
function commaSeparatedToArray(str) {
    if (str === undefined) {
        return [];
    }
    if (!Array.isArray(str)) {
        return [str];
    }
    if (str.length === 0) {
        return str;
    }
    if (str.length === 1) {
        return str[0]
            ?.split(",")
            .map((e) => e.trim())
            .filter((e) => e.length > 0);
    }
    return str;
}
function setupUserConfig({ cli, env, defaults, }) {
    const userConfig = {
        ...defaults,
        ...parseEnvConfig(env),
        ...parseCliConfig(cli),
    };
    userConfig.disabledTools = commaSeparatedToArray(userConfig.disabledTools);
    userConfig.loggers = commaSeparatedToArray(userConfig.loggers);
    if (userConfig.connectionString && userConfig.connectionSpecifier) {
        const connectionInfo = (0, arg_parser_1.generateConnectionInfoFromCliArgs)(userConfig);
        userConfig.connectionString = connectionInfo.connectionString;
    }
    const transport = userConfig.transport;
    if (transport !== "http" && transport !== "stdio") {
        throw new Error(`Invalid transport: ${transport}`);
    }
    const telemetry = userConfig.telemetry;
    if (telemetry !== "enabled" && telemetry !== "disabled") {
        throw new Error(`Invalid telemetry: ${telemetry}`);
    }
    const httpPort = +userConfig.httpPort;
    if (httpPort < 1 || httpPort > 65535 || isNaN(httpPort)) {
        throw new Error(`Invalid httpPort: ${userConfig.httpPort}`);
    }
    if (userConfig.loggers.length === 0) {
        throw new Error("No loggers found in config");
    }
    const loggerTypes = new Set(userConfig.loggers);
    if (loggerTypes.size !== userConfig.loggers.length) {
        throw new Error("Duplicate loggers found in config");
    }
    for (const loggerType of userConfig.loggers) {
        if (loggerType !== "mcp" && loggerType !== "disk" && loggerType !== "stderr") {
            throw new Error(`Invalid logger: ${loggerType}`);
        }
    }
    return userConfig;
}
function setupDriverConfig({ config, defaults, }) {
    const { driverOptions } = (0, arg_parser_1.generateConnectionInfoFromCliArgs)(config);
    return {
        ...defaults,
        ...driverOptions,
    };
}
//# sourceMappingURL=config.js.map