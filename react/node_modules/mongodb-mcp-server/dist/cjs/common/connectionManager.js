"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionManager = void 0;
const service_provider_node_driver_1 = require("@mongosh/service-provider-node-driver");
const events_1 = __importDefault(require("events"));
const connectionOptions_js_1 = require("../helpers/connectionOptions.js");
const packageInfo_js_1 = require("./packageInfo.js");
const mongodb_connection_string_url_1 = __importDefault(require("mongodb-connection-string-url"));
const errors_js_1 = require("./errors.js");
const logger_js_1 = require("./logger.js");
const arg_parser_1 = require("@mongosh/arg-parser");
class ConnectionManager extends events_1.default {
    constructor(userConfig, driverOptions, logger, deviceId, bus) {
        super();
        this.userConfig = userConfig;
        this.driverOptions = driverOptions;
        this.logger = logger;
        this.bus = bus ?? new events_1.default();
        this.state = { tag: "disconnected" };
        this.bus.on("mongodb-oidc-plugin:auth-failed", this.onOidcAuthFailed.bind(this));
        this.bus.on("mongodb-oidc-plugin:auth-succeeded", this.onOidcAuthSucceeded.bind(this));
        this.deviceId = deviceId;
        this.clientName = "unknown";
    }
    setClientName(clientName) {
        this.clientName = clientName;
    }
    async connect(settings) {
        var _a, _b, _c, _d;
        this.emit("connection-request", this.state);
        if (this.state.tag === "connected" || this.state.tag === "connecting") {
            await this.disconnect();
        }
        let serviceProvider;
        let connectionInfo;
        let connectionStringAuthType = "scram";
        try {
            settings = { ...settings };
            const appNameComponents = {
                appName: `${packageInfo_js_1.packageInfo.mcpServerName} ${packageInfo_js_1.packageInfo.version}`,
                deviceId: this.deviceId.get(),
                clientName: this.clientName,
            };
            settings.connectionString = await (0, connectionOptions_js_1.setAppNameParamIfMissing)({
                connectionString: settings.connectionString,
                components: appNameComponents,
            });
            connectionInfo = (0, arg_parser_1.generateConnectionInfoFromCliArgs)({
                ...this.userConfig,
                ...this.driverOptions,
                connectionSpecifier: settings.connectionString,
            });
            if (connectionInfo.driverOptions.oidc) {
                (_a = connectionInfo.driverOptions.oidc).allowedFlows ?? (_a.allowedFlows = ["auth-code"]);
                (_b = connectionInfo.driverOptions.oidc).notifyDeviceFlow ?? (_b.notifyDeviceFlow = this.onOidcNotifyDeviceFlow.bind(this));
            }
            (_c = connectionInfo.driverOptions).proxy ?? (_c.proxy = { useEnvironmentVariableProxies: true });
            (_d = connectionInfo.driverOptions).applyProxyToOIDC ?? (_d.applyProxyToOIDC = true);
            connectionStringAuthType = ConnectionManager.inferConnectionTypeFromSettings(this.userConfig, connectionInfo);
            serviceProvider = await service_provider_node_driver_1.NodeDriverServiceProvider.connect(connectionInfo.connectionString, {
                productDocsLink: "https://github.com/mongodb-js/mongodb-mcp-server/",
                productName: "MongoDB MCP",
                ...connectionInfo.driverOptions,
            }, undefined, this.bus);
        }
        catch (error) {
            const errorReason = error instanceof Error ? error.message : `${error}`;
            this.changeState("connection-error", {
                tag: "errored",
                errorReason,
                connectionStringAuthType,
                connectedAtlasCluster: settings.atlas,
            });
            throw new errors_js_1.MongoDBError(errors_js_1.ErrorCodes.MisconfiguredConnectionString, errorReason);
        }
        try {
            const connectionType = ConnectionManager.inferConnectionTypeFromSettings(this.userConfig, connectionInfo);
            if (connectionType.startsWith("oidc")) {
                void this.pingAndForget(serviceProvider);
                return this.changeState("connection-request", {
                    tag: "connecting",
                    connectedAtlasCluster: settings.atlas,
                    serviceProvider,
                    connectionStringAuthType: connectionType,
                    oidcConnectionType: connectionType,
                });
            }
            await serviceProvider?.runCommand?.("admin", { hello: 1 });
            return this.changeState("connection-success", {
                tag: "connected",
                connectedAtlasCluster: settings.atlas,
                serviceProvider,
                connectionStringAuthType: connectionType,
            });
        }
        catch (error) {
            const errorReason = error instanceof Error ? error.message : `${error}`;
            this.changeState("connection-error", {
                tag: "errored",
                errorReason,
                connectionStringAuthType,
                connectedAtlasCluster: settings.atlas,
            });
            throw new errors_js_1.MongoDBError(errors_js_1.ErrorCodes.NotConnectedToMongoDB, errorReason);
        }
    }
    async disconnect() {
        if (this.state.tag === "disconnected" || this.state.tag === "errored") {
            return this.state;
        }
        if (this.state.tag === "connected" || this.state.tag === "connecting") {
            try {
                await this.state.serviceProvider?.close(true);
            }
            finally {
                this.changeState("connection-close", {
                    tag: "disconnected",
                });
            }
        }
        return { tag: "disconnected" };
    }
    get currentConnectionState() {
        return this.state;
    }
    changeState(event, newState) {
        this.state = newState;
        // TypeScript doesn't seem to be happy with the spread operator and generics
        // eslint-disable-next-line
        this.emit(event, ...[newState]);
        return newState;
    }
    onOidcAuthFailed(error) {
        if (this.state.tag === "connecting" && this.state.connectionStringAuthType?.startsWith("oidc")) {
            void this.disconnectOnOidcError(error);
        }
    }
    onOidcAuthSucceeded() {
        if (this.state.tag === "connecting" && this.state.connectionStringAuthType?.startsWith("oidc")) {
            this.changeState("connection-success", { ...this.state, tag: "connected" });
        }
        this.logger.info({
            id: logger_js_1.LogId.oidcFlow,
            context: "mongodb-oidc-plugin:auth-succeeded",
            message: "Authenticated successfully.",
        });
    }
    onOidcNotifyDeviceFlow(flowInfo) {
        if (this.state.tag === "connecting" && this.state.connectionStringAuthType?.startsWith("oidc")) {
            this.changeState("connection-request", {
                ...this.state,
                tag: "connecting",
                connectionStringAuthType: "oidc-device-flow",
                oidcLoginUrl: flowInfo.verificationUrl,
                oidcUserCode: flowInfo.userCode,
            });
        }
        this.logger.info({
            id: logger_js_1.LogId.oidcFlow,
            context: "mongodb-oidc-plugin:notify-device-flow",
            message: "OIDC Flow changed automatically to device flow.",
        });
    }
    static inferConnectionTypeFromSettings(config, settings) {
        const connString = new mongodb_connection_string_url_1.default(settings.connectionString);
        const searchParams = connString.typedSearchParams();
        switch (searchParams.get("authMechanism")) {
            case "MONGODB-OIDC": {
                if (config.transport === "stdio" && config.browser) {
                    return "oidc-auth-flow";
                }
                if (config.transport === "http" && config.httpHost === "127.0.0.1" && config.browser) {
                    return "oidc-auth-flow";
                }
                return "oidc-device-flow";
            }
            case "MONGODB-X509":
                return "x.509";
            case "GSSAPI":
                return "kerberos";
            case "PLAIN":
                if (searchParams.get("authSource") === "$external") {
                    return "ldap";
                }
                return "scram";
            // default should catch also null, but eslint complains
            // about it.
            case null:
            default:
                return "scram";
        }
    }
    async pingAndForget(serviceProvider) {
        try {
            await serviceProvider?.runCommand?.("admin", { hello: 1 });
        }
        catch (error) {
            this.logger.warning({
                id: logger_js_1.LogId.oidcFlow,
                context: "pingAndForget",
                message: String(error),
            });
        }
    }
    async disconnectOnOidcError(error) {
        try {
            await this.disconnect();
        }
        catch (error) {
            this.logger.warning({
                id: logger_js_1.LogId.oidcFlow,
                context: "disconnectOnOidcError",
                message: String(error),
            });
        }
        finally {
            this.changeState("connection-error", { tag: "errored", errorReason: String(error) });
        }
    }
}
exports.ConnectionManager = ConnectionManager;
//# sourceMappingURL=connectionManager.js.map